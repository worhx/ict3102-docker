{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Rectangle = exports.Circle = exports.PolyLine = exports.SteppedLine = exports.Line = void 0;\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj[\"default\"] = obj;\n    return newObj;\n  }\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar baseStyle = {\n  position: 'absolute',\n  zIndex: 10,\n  backgroundColor: '#000000'\n};\n\nfunction drawLine(from, to, lineWeight, componentStyle) {\n  var m = (to[1] - from[1]) / (to[0] - from[0]);\n  var line = [];\n\n  if (from[0] < to[0]) {\n    for (var x = from[0]; x <= to[0]; x += 0.1) {\n      var y = m * (x - to[0]) + to[1];\n\n      var pixel = _objectSpread({}, componentStyle, {\n        left: \"\".concat(x, \"px\"),\n        top: \"\".concat(y, \"px\"),\n        width: \"\".concat(lineWeight, \"px\"),\n        height: \"\".concat(lineWeight, \"px\")\n      });\n\n      line.push(_react[\"default\"].createElement(\"div\", {\n        style: pixel\n      }));\n    }\n  } else if (from[0] > to[0]) {\n    for (var _x = from[0]; _x >= to[0]; _x -= 0.1) {\n      var _y = m * (_x - to[0]) + to[1];\n\n      var _pixel = _objectSpread({}, componentStyle, {\n        left: \"\".concat(_x, \"px\"),\n        top: \"\".concat(_y, \"px\"),\n        width: \"\".concat(lineWeight, \"px\"),\n        height: \"\".concat(lineWeight, \"px\")\n      });\n\n      line.push(_react[\"default\"].createElement(\"div\", {\n        style: _pixel\n      }));\n    }\n  } else {\n    if (from[1] < to[1]) {\n      for (var _y2 = from[1]; _y2 <= to[1]; _y2 += 0.1) {\n        var _x2 = from[0];\n\n        var _pixel2 = _objectSpread({}, componentStyle, {\n          left: \"\".concat(_x2, \"px\"),\n          top: \"\".concat(_y2, \"px\"),\n          width: \"\".concat(lineWeight, \"px\"),\n          height: \"\".concat(lineWeight, \"px\")\n        });\n\n        line.push(_react[\"default\"].createElement(\"div\", {\n          style: _pixel2\n        }));\n      }\n    } else if (from[1] > to[1]) {\n      for (var _y3 = from[1]; _y3 >= to[1]; _y3 -= 0.1) {\n        var _x3 = from[0];\n\n        var _pixel3 = _objectSpread({}, componentStyle, {\n          left: \"\".concat(_x3, \"px\"),\n          top: \"\".concat(_y3, \"px\"),\n          width: \"\".concat(lineWeight, \"px\"),\n          height: \"\".concat(lineWeight, \"px\")\n        });\n\n        line.push(_react[\"default\"].createElement(\"div\", {\n          style: _pixel3\n        }));\n      }\n    } else {\n      var _x4 = from[0];\n      var _y4 = from[1];\n\n      var _pixel4 = _objectSpread({}, componentStyle, {\n        left: \"\".concat(_x4, \"px\"),\n        top: \"\".concat(_y4, \"px\"),\n        width: \"\".concat(lineWeight, \"px\"),\n        height: \"\".concat(lineWeight, \"px\")\n      });\n\n      line.push(_react[\"default\"].createElement(\"div\", {\n        style: _pixel4\n      }));\n    }\n  }\n\n  return line;\n}\n\nvar Line =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(Line, _Component);\n\n  function Line() {\n    _classCallCheck(this, Line);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Line).apply(this, arguments));\n  }\n\n  _createClass(Line, [{\n    key: \"render\",\n    value: function render() {\n      var componentStyle = _objectSpread({}, baseStyle);\n\n      if (this.props.position === 'fixed') {\n        componentStyle.position = this.props.position;\n      }\n\n      var from;\n      this.props.from ? from = this.props.from : from = [0, 0];\n      var to;\n      this.props.to ? to = this.props.to : to = [0, 0];\n      var lineWeight;\n      this.props.lineWeight ? lineWeight = this.props.lineWeight : lineWeight = 3;\n\n      if (this.props.color) {\n        componentStyle.backgroundColor = this.props.color;\n      }\n\n      if (this.props.zIndex) {\n        componentStyle.zIndex = this.props.zIndex;\n      }\n\n      var line = drawLine(from, to, lineWeight, componentStyle);\n      return _react[\"default\"].createElement(\"div\", null, line);\n    }\n  }]);\n\n  return Line;\n}(_react.Component);\n\nexports.Line = Line;\n\nvar SteppedLine =\n/*#__PURE__*/\nfunction (_Component2) {\n  _inherits(SteppedLine, _Component2);\n\n  function SteppedLine() {\n    _classCallCheck(this, SteppedLine);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(SteppedLine).apply(this, arguments));\n  }\n\n  _createClass(SteppedLine, [{\n    key: \"render\",\n    value: function render() {\n      var componentStyle = _objectSpread({}, baseStyle);\n\n      if (this.props.position === 'fixed') {\n        componentStyle.position = this.props.position;\n      }\n\n      var from;\n      this.props.from ? from = this.props.from : from = [0, 0];\n      var to;\n      this.props.to ? to = this.props.to : to = [0, 0];\n      var lineWeight;\n      this.props.lineWeight ? lineWeight = this.props.lineWeight : lineWeight = 3;\n\n      if (this.props.color) {\n        componentStyle.backgroundColor = this.props.color;\n      }\n\n      if (this.props.zIndex) {\n        componentStyle.zIndex = this.props.zIndex;\n      }\n\n      var _from = from,\n          _from2 = _slicedToArray(_from, 2),\n          x1 = _from2[0],\n          y1 = _from2[1];\n\n      var _to = to,\n          _to2 = _slicedToArray(_to, 2),\n          x2 = _to2[0],\n          y2 = _to2[1];\n\n      var midx = x1 + (x2 - x1) / 2;\n\n      var line1 = _objectSpread({}, componentStyle, {\n        left: \"\".concat(midx >= x1 ? x1 : midx, \"px\"),\n        top: \"\".concat(y1, \"px\"),\n        width: \"\".concat(Math.abs((x2 - x1) / 2), \"px\"),\n        height: \"\".concat(lineWeight, \"px\")\n      });\n\n      var line2 = _objectSpread({}, componentStyle, {\n        left: \"\".concat(midx, \"px\"),\n        top: \"\".concat(y2 >= y1 ? y1 : y2, \"px\"),\n        width: \"\".concat(lineWeight, \"px\"),\n        height: \"\".concat(y2 - y1 === 0 ? 0 : Math.abs(y2 - y1) + lineWeight, \"px\")\n      });\n\n      var line3 = _objectSpread({}, componentStyle, {\n        left: \"\".concat(x2 >= midx ? midx : x2, \"px\"),\n        top: \"\".concat(y2, \"px\"),\n        width: \"\".concat(Math.abs((x2 - x1) / 2), \"px\"),\n        height: \"\".concat(lineWeight, \"px\")\n      });\n\n      return _react[\"default\"].createElement(_react[\"default\"].Fragment, null, _react[\"default\"].createElement(\"div\", {\n        style: line1\n      }), _react[\"default\"].createElement(\"div\", {\n        style: line2\n      }), _react[\"default\"].createElement(\"div\", {\n        style: line3\n      }));\n    }\n  }]);\n\n  return SteppedLine;\n}(_react.Component);\n\nexports.SteppedLine = SteppedLine;\n\nvar PolyLine =\n/*#__PURE__*/\nfunction (_Component3) {\n  _inherits(PolyLine, _Component3);\n\n  function PolyLine() {\n    _classCallCheck(this, PolyLine);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(PolyLine).apply(this, arguments));\n  }\n\n  _createClass(PolyLine, [{\n    key: \"render\",\n    value: function render() {\n      var componentStyle = _objectSpread({}, baseStyle);\n\n      if (this.props.position === 'fixed') {\n        componentStyle.position = this.props.position;\n      }\n\n      var lines = [];\n      var points;\n\n      if (this.props.points) {\n        var from = this.props.points.slice(0, -1);\n        var to = this.props.points.slice(1);\n        points = from.map(function (_, i) {\n          return [from[i], to[i]];\n        });\n      } else {\n        points = [[0, 0], [0, 0]];\n      }\n\n      var lineWeight;\n      this.props.lineWeight ? lineWeight = this.props.lineWeight : lineWeight = 3;\n\n      if (this.props.color) {\n        componentStyle.backgroundColor = this.props.color;\n      }\n\n      if (this.props.zIndex) {\n        componentStyle.zIndex = this.props.zIndex;\n      }\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = points[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _step$value = _slicedToArray(_step.value, 2),\n              _from3 = _step$value[0],\n              _to3 = _step$value[1];\n\n          lines.push.apply(lines, _toConsumableArray(drawLine(_from3, _to3, lineWeight, componentStyle)));\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return _react[\"default\"].createElement(\"div\", null, lines);\n    }\n  }]);\n\n  return PolyLine;\n}(_react.Component);\n\nexports.PolyLine = PolyLine;\n\nvar Circle =\n/*#__PURE__*/\nfunction (_Component4) {\n  _inherits(Circle, _Component4);\n\n  function Circle() {\n    _classCallCheck(this, Circle);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Circle).apply(this, arguments));\n  }\n\n  _createClass(Circle, [{\n    key: \"render\",\n    value: function render() {\n      var componentStyle = _objectSpread({}, baseStyle);\n\n      if (this.props.position === 'fixed') {\n        componentStyle.position = this.props.position;\n      }\n\n      var circle = [];\n      var center;\n      this.props.center ? center = this.props.center : center = [0, 0];\n      var radius;\n      this.props.radius ? radius = this.props.radius : radius = 1;\n      var lineWeight;\n      this.props.lineWeight ? lineWeight = this.props.lineWeight : lineWeight = 3;\n\n      if (this.props.color) {\n        componentStyle.backgroundColor = this.props.color;\n      }\n\n      if (this.props.zIndex) {\n        componentStyle.zIndex = this.props.zIndex;\n      }\n\n      for (var x = center[0] - radius; x <= center[0] + radius; x += 0.01) {\n        var yb = center[1] + Math.sqrt(Math.pow(radius, 2) - Math.pow(x - center[0], 2));\n        var yt = center[1] - Math.sqrt(Math.pow(radius, 2) - Math.pow(x - center[0], 2));\n\n        var pixelB = _objectSpread({}, componentStyle, {\n          left: \"\".concat(x, \"px\"),\n          top: \"\".concat(yb, \"px\"),\n          width: \"\".concat(lineWeight, \"px\"),\n          height: \"\".concat(lineWeight, \"px\")\n        });\n\n        var pixelT = _objectSpread({}, componentStyle, {\n          left: \"\".concat(x, \"px\"),\n          top: \"\".concat(yt, \"px\"),\n          width: \"\".concat(lineWeight, \"px\"),\n          height: \"\".concat(lineWeight, \"px\")\n        });\n\n        circle.push(_react[\"default\"].createElement(\"div\", {\n          style: pixelB\n        }));\n        circle.push(_react[\"default\"].createElement(\"div\", {\n          style: pixelT\n        }));\n      }\n\n      return _react[\"default\"].createElement(\"div\", null, circle);\n    }\n  }]);\n\n  return Circle;\n}(_react.Component);\n\nexports.Circle = Circle;\n\nvar Rectangle =\n/*#__PURE__*/\nfunction (_Component5) {\n  _inherits(Rectangle, _Component5);\n\n  function Rectangle() {\n    _classCallCheck(this, Rectangle);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Rectangle).apply(this, arguments));\n  }\n\n  _createClass(Rectangle, [{\n    key: \"render\",\n    value: function render() {\n      var componentStyle = _objectSpread({}, baseStyle);\n\n      if (this.props.position === 'fixed') {\n        componentStyle.position = this.props.position;\n      }\n\n      var rectangle = [];\n      var corner;\n      this.props.corner ? corner = this.props.corner : corner = [0, 0];\n      var height;\n      this.props.height ? height = this.props.height : height = 1;\n      var width;\n      this.props.width ? width = this.props.width : width = 1;\n      var lineWeight;\n      this.props.lineWeight ? lineWeight = this.props.lineWeight : lineWeight = 3;\n\n      if (this.props.color) {\n        componentStyle.backgroundColor = this.props.color;\n      }\n\n      if (this.props.zIndex) {\n        componentStyle.zIndex = this.props.zIndex;\n      }\n\n      var corners = [[corner[0], corner[1]], [corner[0] + width, corner[1]], [corner[0] + width, corner[1] + height], [corner[0], corner[1] + height], [corner[0], corner[1]]];\n      var from = corners.slice(0, -1);\n      var to = corners.slice(1);\n      var points = from.map(function (_, i) {\n        return [from[i], to[i]];\n      });\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = points[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var _step2$value = _slicedToArray(_step2.value, 2),\n              _from4 = _step2$value[0],\n              _to4 = _step2$value[1];\n\n          rectangle.push.apply(rectangle, _toConsumableArray(drawLine(_from4, _to4, lineWeight, componentStyle)));\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return _react[\"default\"].createElement(\"div\", null, rectangle);\n    }\n  }]);\n\n  return Rectangle;\n}(_react.Component);\n\nexports.Rectangle = Rectangle;","map":null,"metadata":{},"sourceType":"script"}